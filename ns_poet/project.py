"""Contains a configuration parser and project config singleton"""
import json
from pathlib import Path
from typing import Any, Dict, List, Optional, Set
from pkg_resources import Requirement
import pkg_resources

import toml

from .util import get_git_top_level_path


class PoetProject:
    """Project object

    The schema for the file in the git project root is::

        [tool.nspoet]
        ignore_dirs = []
        ignore_targets = []
        python_package_name_prefix = ""
        import_map_path = "3rdparty/python/import-map.json"
        requirements_path = "3rdparty/python/requirements.txt"
        top_dirs = ["."]
        default_python_version = "^3.6.5"

    """

    def __init__(self, project_path: Path) -> None:
        """Initializer

        Args:
            project_path: Path to the project

        """
        self.project_path = project_path
        self.config_file_path = project_path.joinpath("pyproject.toml")
        self._config: Optional[Dict[str, Any]] = None
        self._requirements: Optional[Dict[str, Requirement]] = None
        self._import_map: Optional[Dict[str, str]] = None

    @classmethod
    def from_path(cls, project_path: Path) -> "PoetProject":
        p = cls(project_path)
        p.load_config()
        return p

    def load_config(self) -> Dict[str, Any]:
        if self.config_file_path.is_file():
            with self.config_file_path.open() as f:
                self._config = toml.load(f)
        else:
            self._config = {}

        return self._config

    @property
    def project_config(self) -> Dict[str, Any]:
        return self._config.get("tool", {}).get("nspoet", {})

    @property
    def ignore_dirs(self) -> Set[str]:
        """Never look for or process files in these directories"""
        return frozenset(self.project_config.get("ignore_dirs", []))

    @property
    def ignore_targets(self) -> Set[str]:
        """Set of target package names to ignore when collecting build targets"""
        return frozenset(self.project_config.get("ignore_targets", []))

    @property
    def python_package_name_prefix(self) -> str:
        """Prefix to use for names of packages generated by pypants"""
        return self.project_config.get("python_package_name_prefix", "")

    @property
    def import_map_path(self) -> Path:
        """Path to the location of the import-map.json file relative to the project root"""
        return Path(
            self.project_config.get(
                "import_map_path",
                "import-map.json",
            )
        )

    @property
    def requirements_path(self) -> Path:
        """Path to the requirements.txt relative to the project root"""
        return Path(
            self.project_config.get(
                "requirements_path",
                "requirements.txt",
            )
        )

    @property
    def top_dirs(self) -> List[str]:
        """Top-level directories to search for Python packages"""
        return self.project_config.get("top_dirs", ["."])

    @property
    def default_python_version(self) -> str:
        """Default python version"""
        return self.project_config.get("default_python_version", "^3.6.5")

    def load_requirements(self) -> Dict[str, Requirement]:
        if not self._requirements:
            with self.requirements_path.open() as f:
                self._requirements = {
                    r.name: r for r in pkg_resources.parse_requirements(f.read())
                }

        return self._requirements

    def get_requirement(self, name: str) -> Requirement:
        return self._requirements[name]

    def load_import_map(self) -> Dict[str, str]:
        # This file contains a map from the import name found in *.py to the library's
        # project name (i.e. requirements.txt name)
        try:
            with self.import_map_path.open() as f:
                return json.load(f)
        except FileNotFoundError:
            return {}

    def get_import_map(self) -> Dict[str, str]:
        if not self._import_map:
            self._import_map = self.load_import_map()

        return self._import_map

    def update_import_map(self, import_map: Dict[str, str]) -> None:
        with self.import_map_path.open("w") as f:
            json.dump(import_map, f, sort_keys=True, indent=2)
            f.write("\n")


# Create a singleton for the project configuration
PROJECT_CONFIG = PoetProject.from_path(get_git_top_level_path())
